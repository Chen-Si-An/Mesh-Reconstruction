// MeshReconstruction.cpp : 此檔案包含 'main' 函式。程式會於該處開始執行及結束執行。
//

#include <Windows.h>
#include "ReadPLY.h"
#include "PCLLib.h"
#include "BallPivoting.h"
#include <fstream>
#include <time.h>

bool WriteSTL(const MESH_DATA &meshData, const string &strPath);

int main()
{
	char chBuf[MAX_PATH];
	GetModuleFileNameA(NULL, chBuf, MAX_PATH);
	string strPath(chBuf);
	size_t iPos = strPath.find_last_of("\\/");
	strPath = strPath.substr(0, iPos) + "\\";

	string strPLY;
	cout << "Please input file name of ply:" << endl;
	cin >> strPLY;
	cout  << endl;

	MESH_DATA meshData;
	MESH_DATA meshPoisson;
	MESH_DATA meshBPA;
	clock_t tTime;
	if (ReadPLY(strPath + strPLY + ".ply", meshData))
		if (meshData.NbTriangles() == 0)
		{
			if (!meshData.HasNormals())
				::NormalEstimation(meshData);

			tTime = clock();
			PoissonSurfaceReconstruction(meshData, meshPoisson);
			cout << "Poisson: " << (clock() - tTime) / 1000. << " s" << endl;

			tTime = clock();
			BPASurfaceReconstruction(meshData, meshBPA);
			cout << "Ball pivoting: " << (clock() - tTime) / 1000. << " s\n" << endl;
		}

	if (meshData.NbTriangles() != 0)
		WriteSTL(meshData, strPath + strPLY + ".stl");
	if (meshPoisson.NbTriangles() != 0)
		WriteSTL(meshPoisson, strPath + strPLY + "_Poisson.stl");
	if (meshBPA.NbTriangles() != 0)
#ifndef SUP_GPU
		WriteSTL(meshBPA, strPath + strPLY + "_BPA_OMP.stl");
#else
		WriteSTL(meshBPA, strPath + strPLY + "_BPA_GPU.stl");
#endif // !SUP_GPU

	system("pause");
	return 0;
}

bool WriteSTL(const MESH_DATA &meshData, const string &strPath)
{
	ofstream fout;
	fout.open(strPath);
	if (!fout.is_open())
		return false;

	fout << "solid STL generated by Allen" << endl;

	CDot dotVertex[3];
	CDot dotVec1, dotVec2, dotNorm;
	for (int i = 0; i < meshData.NbTriangles(); i++)
	{
		for (int j = 0; j < 3; j++)
			dotVertex[j] = meshData.m_ayDot[meshData.m_ayFace[3 * i + j]];

		dotVec1 = dotVertex[1] - dotVertex[0];
		dotVec2 = dotVertex[2] - dotVertex[0];
		dotNorm.m_x = dotVec1.m_y * dotVec2.m_z - dotVec1.m_z * dotVec2.m_y;
		dotNorm.m_y = dotVec1.m_z * dotVec2.m_x - dotVec1.m_x * dotVec2.m_z;
		dotNorm.m_z = dotVec1.m_x * dotVec2.m_y - dotVec1.m_y * dotVec2.m_x;

		fout << "  facet normal  " << dotNorm.m_x << " " << dotNorm.m_y << " " << dotNorm.m_z << endl;
		fout << "    outer loop" << endl;
		fout << "      vertex   " << dotVertex[0].m_x << " " << dotVertex[0].m_y << " " << dotVertex[0].m_z << " " << endl;
		fout << "      vertex   " << dotVertex[1].m_x << " " << dotVertex[1].m_y << " " << dotVertex[1].m_z << " " << endl;
		fout << "      vertex   " << dotVertex[2].m_x << " " << dotVertex[2].m_y << " " << dotVertex[2].m_z << " " << endl;
		fout << "    endloop" << endl;
		fout << "  endfacet" << endl;
	}
	fout << "endsolid" << endl;

	fout.close();
	
	return true;
}